### 1.请输出下列最终的执行结果，并解释为什么。

```JavaScript
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    }
}
a[6]()
```

**答案**：输出10

**原因**：

- a[6]这个函数调用后，进入调用栈，
- 此时作用域链为 a[6]函数内部词法环境和全局词法环境，
- 内部语句console.log(i) 运行时，根据变量搜索规则查找到的是变量i是全局词法环境下的i，
- 但这时全局词法环境的i已经变化为10，所以输出10。

### 2.请说出下列最终的执行结果，并解释为什么。

```javascript
var tmp = 123;
if(true) {
    console.log(tmp);
    let tmp
}
```

**答案**：报错，在声明前使用

**原因**：

- 全局词法环境里用var注册了一个tmp变量
- 块级词法环境下用let注册了一个tmp变量
- 在console.log(tmp)语句运行时，优先找到块级词法环境下用let声明的tmp变量，但是let不允许“变量提升”，所以报错声明前使用。

### 3.结合ES6新语法，用最简单的方式找出数组中的最小值。

```javascript
var arr = [12, 34, 32, 89, 4];
```

**答案**：

```javascript
Math.min(...arr)
```

### 4.请详细说明var，let，const三种声明变量的方式之间的具体差别。

var与let、const

- 注册位置：var声明的变量注册在最近的函数词法环境下或者全局词法环境下，而let与const声明的变量注册在最近的词法环境下。
- 变量提升：var声明的变量会变量提升，而let与const声明的变量不会变量提升
- 重复声明：var允许重复声明同一个变量，而let与const不允许。

var、let与const

- var、let声明的变量指向一个地址后可以更改
- const声明的变量指向一个地址后不能再发生改变

### 5.请说出下列代码最终输出的结果，并解释为什么。

```javascript
var a = 10;
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a)
        })
    }
}

obj.fn()
```

**答案**：20

- 箭头函数没有this，
- 在箭头函数调用时，其内部的this引用会从作用域链中搜索
- 从最近的词法环境 / 作用域 obj中找到了this
- this指向obj，所有this.a返回20

### 6.简述Symbol类型的用途。

- 消除魔法字符串
- 实现对象 / 类的私有成员

### 7.说说什么是浅拷贝，什么是深拷贝？

- 浅拷贝只拷贝引用
- 深拷贝会拷贝对象本身（对属性浅拷贝）
- 递归拷贝会完全拷贝对象（对属性也深拷贝）

### 8.请简述Typescript与JavaScript之间的关系。

- TypeScript是JavaScript的超集
- Typescript中支持类型系统和ES6语法，经过编译后得到JavaScript代码

### 9.请谈谈你所认为的TypeScript优缺点。

- 优点：借鉴了其它静态语言的做法，定义了一套优秀的类型系统，解决了JavaScript的类型系统缺陷问题
- 缺点：需要学习使用一套新的类型系统，在开发阶段处处都是类型约束，初期开发繁琐。使用的第三方代码必须也是Typescript代码，或者引入单独的类型声明文件，否则就要自己给它定义类型才能使用。

### 10.描述引用计数的工作原理和优缺点。

**工作原理：**

通过一个引用计数器来维护当前对象所占用内存空间的引用数量，引用关系改变时修改引用数字，引用数字为0时立即回收。

**优缺点**：

- 优点：垃圾对象可以立即回收

- 缺点：不能回收循环引用的垃圾对象，时间开销大。

### 11.描述标记整理算法上的工作流程。

- 标记阶段：负责标记活动对象
- 整理阶段：移动活动对象位置，防止碎片化
- 清除阶段：清除未标记对象

### 12.描述V8中新生代存储区垃圾回收的流程。

- 新生代对象回收：标记阶段为from空间内的活动对象打上标记，整理阶段把所有标记对象拷贝到To空间中（如果To空间使用率超过25%就晋升为老生代对象），回收阶段把from空间和to空间互换后释放from空间。
- 老生代对象回收：使用标记清除算法完成垃圾空间的回收，此时虽然会造成空间碎片化问题但性能比标记整理更快。当把新生代对象移动到老生代存储区时遇到空间不足时则会触发标记整理进行空间优化。

### 13.描述增量标记算法在何时使用及工作原理。

垃圾回收时会阻塞JavaScript程序的执行，垃圾回收时间一长就会导致页面卡死。使用增量标记算法可以将垃圾回收的标记阶段一整段的标记阶段拆分成多次，让程序执行和垃圾回收交替完成。